{
    "docs": [
        {
            "location": "/",
            "text": "Django-Flags\n\u00b6\n\n\nFeature flags allow you to toggle functionality in both Django code and the Django templates based on configurable conditions. Flags can be useful for staging feature deployments, for A/B testing, or for any time you need an on/off switch for blocks of code. The toggle can be by date, user, URL value, or a number of \nother conditions\n, editable in the admin or in definable in settings.\n\n\nDependencies\n\u00b6\n\n\n\n\nDjango 1.8+ (including Django 2.0)\n\n\nPython 2.7+, 3.6+\n\n\n\n\nInstallation\n\u00b6\n\n\nFirst, install django-flags:\n\n\npip install django-flags\n\n\n\nThen add \nflags\n as an installed app in your Django \nsettings.py\n:\n\n\nINSTALLED_APPS = (\n    # \u2026\n    'flags',\n    # \u2026\n)\n\n\n\nAnd \ndjango.template.context_processors.request\n to the \nTEMPLATES\n \ncontext_processors\n setting so that the \nrequest\n variable is available:\n\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        # \u2026\n        'OPTIONS': {\n            # \u2026\n            'context_processors': [\n                # \u2026\n                'django.core.context_processors.request',\n                # \u2026\n            ],\n            # \u2026\n        },\n        # \u2026\n    },\n]\n\n\n\n(Optionally) add \nflags.middleware.FlagConditionsMiddleware\n to \nMIDDLEWARE\n to avoid looking up flag conditions more than once per request:\n\n\nMIDDLEWARE = (\n    # \u2026\n    'flags.middleware.FlagConditionsMiddleware',\n    # \u2026\n)\n\n\n\nFinally, run migrations:\n\n\n./manage.py migrate\n\n\n\nConcepts\n\u00b6\n\n\nFeature flags in Django-Flags are identified by simple strings that are enabled when the conditions they are associated with are met. These flags can be used to wrap code and template content that should only be used when a flag is enabled or disabled.\n\n\nConditions determine whether a flag is enabled or disabled by comparing a defined expected value of some kind with the value at the time the flag is checked. In many cases, the flag is checked during a request, and some piece of the request's metadata is what is compared. For example, a feature flag that is enabled for a specific user would be enabled if the request's user matches the condition's user.\n\n\nQuickstart\n\u00b6\n\n\nTo use Django-Flags you first need to define the flag, use the flag, and define conditions for the flag to be enabled.\n\n\nFirst, define the flag in Django \nsettings.py\n:\n\n\nFLAGS = {\n    'MY_FLAG': {}\n}\n\n\n\nThen use the flag in a Django template (\nmytemplate.html\n):\n\n\n{% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n\n{% if my_flag %}\n  <div class=\"flagged-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nConfigure a URL for that template (\nurls.py\n):\n\n\nDjango 2.0:\n\n\nfrom django.urls import path\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    path(r'mypage/', TemplateView.as_view(template_name='mytemplate.html')),\n]\n\n\n\nDjango 1.x:\n\n\nfrom django.conf.urls import url\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    url(r'^mypage/$', TemplateView.as_view(template_name='mytemplate.html')),\n]\n\n\n\nThen in the Django admin add conditions for the flag in \"Django Flags\", \"Flag states\":\n\n\n\n\nThen visiting the URL \n/mypage?enable_my_flag=True\n should show you the flagged \n<div>\n in the template.",
            "title": "Getting started"
        },
        {
            "location": "/#django-flags",
            "text": "Feature flags allow you to toggle functionality in both Django code and the Django templates based on configurable conditions. Flags can be useful for staging feature deployments, for A/B testing, or for any time you need an on/off switch for blocks of code. The toggle can be by date, user, URL value, or a number of  other conditions , editable in the admin or in definable in settings.",
            "title": "Django-Flags"
        },
        {
            "location": "/#dependencies",
            "text": "Django 1.8+ (including Django 2.0)  Python 2.7+, 3.6+",
            "title": "Dependencies"
        },
        {
            "location": "/#installation",
            "text": "First, install django-flags:  pip install django-flags  Then add  flags  as an installed app in your Django  settings.py :  INSTALLED_APPS = (\n    # \u2026\n    'flags',\n    # \u2026\n)  And  django.template.context_processors.request  to the  TEMPLATES   context_processors  setting so that the  request  variable is available:  TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        # \u2026\n        'OPTIONS': {\n            # \u2026\n            'context_processors': [\n                # \u2026\n                'django.core.context_processors.request',\n                # \u2026\n            ],\n            # \u2026\n        },\n        # \u2026\n    },\n]  (Optionally) add  flags.middleware.FlagConditionsMiddleware  to  MIDDLEWARE  to avoid looking up flag conditions more than once per request:  MIDDLEWARE = (\n    # \u2026\n    'flags.middleware.FlagConditionsMiddleware',\n    # \u2026\n)  Finally, run migrations:  ./manage.py migrate",
            "title": "Installation"
        },
        {
            "location": "/#concepts",
            "text": "Feature flags in Django-Flags are identified by simple strings that are enabled when the conditions they are associated with are met. These flags can be used to wrap code and template content that should only be used when a flag is enabled or disabled.  Conditions determine whether a flag is enabled or disabled by comparing a defined expected value of some kind with the value at the time the flag is checked. In many cases, the flag is checked during a request, and some piece of the request's metadata is what is compared. For example, a feature flag that is enabled for a specific user would be enabled if the request's user matches the condition's user.",
            "title": "Concepts"
        },
        {
            "location": "/#quickstart",
            "text": "To use Django-Flags you first need to define the flag, use the flag, and define conditions for the flag to be enabled.  First, define the flag in Django  settings.py :  FLAGS = {\n    'MY_FLAG': {}\n}  Then use the flag in a Django template ( mytemplate.html ):  {% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n\n{% if my_flag %}\n  <div class=\"flagged-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}  Configure a URL for that template ( urls.py ):  Django 2.0:  from django.urls import path\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    path(r'mypage/', TemplateView.as_view(template_name='mytemplate.html')),\n]  Django 1.x:  from django.conf.urls import url\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    url(r'^mypage/$', TemplateView.as_view(template_name='mytemplate.html')),\n]  Then in the Django admin add conditions for the flag in \"Django Flags\", \"Flag states\":   Then visiting the URL  /mypage?enable_my_flag=True  should show you the flagged  <div>  in the template.",
            "title": "Quickstart"
        },
        {
            "location": "/usage/",
            "text": "Usage guide\n\u00b6\n\n\nDefining flags\n\u00b6\n\n\nFlags are defined in Django settings with the conditions in which they are enabled.\n\n\nFLAGS = {\n  'FLAG_WITH_EMPTY_CONDITIONS': {}\n  'MY_FLAG': {\n    'condition name': 'value flag is expected to match to be enabled',\n    'user': 'lady.liberty'\n  }\n}\n\n\n\nThe set of conditions can be none (flag will never be enabled), one (only condition that has to be met for the flag to be enabled), or many (all have to be met for the flag to be enabled).\n\n\nAdditional conditions can be added in the Django admin for any defined flag (illustrated in \nQuickstart\n). Conditions added in the Django admin can be changed without restarting Django, conditions defined in \nsettings.py\n cannot. See \nthe list of built-in conditions\n.\n\n\nUsing flags in code\n\u00b6\n\n\nFlags can be used in Python code:\n\n\nfrom flags.state import flag_enabled\n\nif flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\") \n\n\n\nDjango templates:\n\n\n{% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nJinja2 templates (after \nadding \nflag_enabled\n to the Jinja2 environment\n):\n\n\n{% if flag_enabled('MY_FLAG', request) %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nDjango 2.0 \nurls.py\n:\n\n\nfrom flags.urls import flagged_path\n\nurlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n]\n\n\n\nAnd Django 1.x \nurls.py\n:\n\n\nfrom flags.urls import flagged_url\n\nurlpatterns = [\n    flagged_url('MY_FLAG', r'^a-url$', view_requiring_flag, state=True),\n]\n\n\n\nSee the \nAPI reference\n for more details and examples.",
            "title": "Usage guide"
        },
        {
            "location": "/usage/#usage-guide",
            "text": "",
            "title": "Usage guide"
        },
        {
            "location": "/usage/#defining-flags",
            "text": "Flags are defined in Django settings with the conditions in which they are enabled.  FLAGS = {\n  'FLAG_WITH_EMPTY_CONDITIONS': {}\n  'MY_FLAG': {\n    'condition name': 'value flag is expected to match to be enabled',\n    'user': 'lady.liberty'\n  }\n}  The set of conditions can be none (flag will never be enabled), one (only condition that has to be met for the flag to be enabled), or many (all have to be met for the flag to be enabled).  Additional conditions can be added in the Django admin for any defined flag (illustrated in  Quickstart ). Conditions added in the Django admin can be changed without restarting Django, conditions defined in  settings.py  cannot. See  the list of built-in conditions .",
            "title": "Defining flags"
        },
        {
            "location": "/usage/#using-flags-in-code",
            "text": "Flags can be used in Python code:  from flags.state import flag_enabled\n\nif flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\")   Django templates:  {% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}  Jinja2 templates (after  adding  flag_enabled  to the Jinja2 environment ):  {% if flag_enabled('MY_FLAG', request) %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}  Django 2.0  urls.py :  from flags.urls import flagged_path\n\nurlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n]  And Django 1.x  urls.py :  from flags.urls import flagged_url\n\nurlpatterns = [\n    flagged_url('MY_FLAG', r'^a-url$', view_requiring_flag, state=True),\n]  See the  API reference  for more details and examples.",
            "title": "Using flags in code"
        },
        {
            "location": "/settings/",
            "text": "Settings\n\u00b6\n\n\nDefining flags\n\u00b6\n\n\nFLAGS_SOURCES\n\u00b6\n\n\nDefault: \n('flags.sources.SettingsFlagsSource', 'flags.sources.DatabaseFlagsSource',)\n\n\nA list or tuple containing the full Python path strings to classes that provides a \nget_flags()\n method\n. The \nget_flags()\n method is expected to return a dictionary of flags and \nCondition\n objects\n. All flags returned by all flag sources will be available to check.\n\n\nFLAGS\n\u00b6\n\n\nDefault: \n{}\n\n\nA dictionary of feature flags and optional conditions used when \n'flags.sources.SettingsFlagsSource'\n is in \nFLAGS_SOURCES\n.\n\n\nConditions can either be included as:\n\n\n\n\nA dictionary with the condition name as the key and expected value as value\n\n\nA list of 2-tuples with the format \n(condition name: expected value)\n\n\n\n\nFLAGS = {\n  'FLAG_WITH_EMPTY_CONDITIONS': {}\n  'FLAG_WITH_DICT_CONDITIONS': {\n    'condition name': 'value flag is expected to match to be enabled',\n  },\n  'FLAG_WITH_LISTED_CONDITIONS': [\n    ('path matches',  r'^/matching-path.*'),\n    ('path matches',  r'^/other-path.*'),\n  ]\n}\n\n\n\nThe advantage of a list of 2-tuples is that the same condition can be repeated for different expected values.",
            "title": "Settings"
        },
        {
            "location": "/settings/#settings",
            "text": "",
            "title": "Settings"
        },
        {
            "location": "/settings/#defining-flags",
            "text": "",
            "title": "Defining flags"
        },
        {
            "location": "/settings/#flags_sources",
            "text": "Default:  ('flags.sources.SettingsFlagsSource', 'flags.sources.DatabaseFlagsSource',)  A list or tuple containing the full Python path strings to classes that provides a  get_flags()  method . The  get_flags()  method is expected to return a dictionary of flags and  Condition  objects . All flags returned by all flag sources will be available to check.",
            "title": "FLAGS_SOURCES"
        },
        {
            "location": "/settings/#flags",
            "text": "Default:  {}  A dictionary of feature flags and optional conditions used when  'flags.sources.SettingsFlagsSource'  is in  FLAGS_SOURCES .  Conditions can either be included as:   A dictionary with the condition name as the key and expected value as value  A list of 2-tuples with the format  (condition name: expected value)   FLAGS = {\n  'FLAG_WITH_EMPTY_CONDITIONS': {}\n  'FLAG_WITH_DICT_CONDITIONS': {\n    'condition name': 'value flag is expected to match to be enabled',\n  },\n  'FLAG_WITH_LISTED_CONDITIONS': [\n    ('path matches',  r'^/matching-path.*'),\n    ('path matches',  r'^/other-path.*'),\n  ]\n}  The advantage of a list of 2-tuples is that the same condition can be repeated for different expected values.",
            "title": "FLAGS"
        },
        {
            "location": "/conditions/",
            "text": "Conditions\n\u00b6\n\n\nBuilt-in conditions\n\u00b6\n\n\nDjango-Flags comes with the following conditions built-in:\n\n\nboolean\n\u00b6\n\n\nA simple boolean true/false intended to enable or disable a flag explicitly. The state of the flag evaluates to the value of the boolean condition.\n\n\nFLAGS = {'MY_FLAG': {'boolean': True}}\n\n\n\nuser\n\u00b6\n\n\nAllows a flag to be enabled for the username given as the condition's value.\n\n\nFLAGS = {'MY_FLAG': {'user': 'jane.doe'}}\n\n\n\nanonymous\n\u00b6\n\n\nAllows a flag to be either enabled or disabled depending on the condition's boolean value.\n\n\nFLAGS = {'MY_FLAG': {'anonymous': False}}\n\n\n\nparameter\n\u00b6\n\n\nAllows a flag to be enabled based on a GET parameter with the name given as the condition's value.\n\n\nFLAGS = {'MY_FLAG': {'parameter': 'my_flag_param'}}\n\n\n\npath\n\u00b6\n\n\nAllows a flag to be enabled if the request's path matches the condition value.\n\n\nFLAGS = {'MY_FLAG': {'path': '/flagged/path'}}\n\n\n\nafter date\n\u00b6\n\n\nAllows a flag to be enabled after a given date (and time) given in \nISO 8601 format\n. The time must be specified either in UTC or as an offset from UTC.\n\n\nFLAGS = {'MY_FLAG': {'after date': '2017-06-01T12:00Z'}}\n\n\n\nCustom conditions\n\u00b6\n\n\nCustom conditions can be created and registered for use using the \nconditions API\n.",
            "title": "Conditions"
        },
        {
            "location": "/conditions/#conditions",
            "text": "",
            "title": "Conditions"
        },
        {
            "location": "/conditions/#built-in-conditions",
            "text": "Django-Flags comes with the following conditions built-in:",
            "title": "Built-in conditions"
        },
        {
            "location": "/conditions/#boolean",
            "text": "A simple boolean true/false intended to enable or disable a flag explicitly. The state of the flag evaluates to the value of the boolean condition.  FLAGS = {'MY_FLAG': {'boolean': True}}",
            "title": "boolean"
        },
        {
            "location": "/conditions/#user",
            "text": "Allows a flag to be enabled for the username given as the condition's value.  FLAGS = {'MY_FLAG': {'user': 'jane.doe'}}",
            "title": "user"
        },
        {
            "location": "/conditions/#anonymous",
            "text": "Allows a flag to be either enabled or disabled depending on the condition's boolean value.  FLAGS = {'MY_FLAG': {'anonymous': False}}",
            "title": "anonymous"
        },
        {
            "location": "/conditions/#parameter",
            "text": "Allows a flag to be enabled based on a GET parameter with the name given as the condition's value.  FLAGS = {'MY_FLAG': {'parameter': 'my_flag_param'}}",
            "title": "parameter"
        },
        {
            "location": "/conditions/#path",
            "text": "Allows a flag to be enabled if the request's path matches the condition value.  FLAGS = {'MY_FLAG': {'path': '/flagged/path'}}",
            "title": "path"
        },
        {
            "location": "/conditions/#after-date",
            "text": "Allows a flag to be enabled after a given date (and time) given in  ISO 8601 format . The time must be specified either in UTC or as an offset from UTC.  FLAGS = {'MY_FLAG': {'after date': '2017-06-01T12:00Z'}}",
            "title": "after date"
        },
        {
            "location": "/conditions/#custom-conditions",
            "text": "Custom conditions can be created and registered for use using the  conditions API .",
            "title": "Custom conditions"
        },
        {
            "location": "/api/sources/",
            "text": "Flag Sources\n\u00b6\n\n\nDjango-Flags provides a means to provide custom flag sources using the \nFLAG_SOURCES\n setting\n. Flag sources are classes that provide a \nget_flags\n method. The \nget_flags\n method must return a dictionary of flag name keys with a list of \nCondition\n objects.\n\n\nfrom flags.sources import Condition\n\n\nclass CustomFlagSource(object):\n\n    def get_flags(self):\n        flags = {\n            'MY_FLAG': [\n                Condition('parameter', 'enable_my_flag'),\n            ]\n        }\n        return flags\n\n\n\nAPI\n\u00b6\n\n\nget_flags(sources=None)\n\u00b6\n\n\nReturn a dictionary of all flag names with \nFlag\n objects that are available in the given \nsources\n. If \nsources\n is not given, the sources in the \nFLAG_SOURCES\n setting\n are used.\n\n\nCondition(condition, value, source=None, obj=None)\n\u00b6\n\n\nA simple wrapper around conditions.\n\n\nCondition.check(*kwargs)\n\u00b6\n\n\nCheck the condition against the given keyword arguments.\n\n\nFlag(name, conditions=[])\n\u00b6\n\n\nA simple wrapper around flags and their conditions. \nconditions\n is a list of \nCondition\n objects.\n\n\nFlag.check_state(*kwargs)\n\u00b6\n\n\nCheck all of a flag's conditions and return the state based on the given keyword arguments.",
            "title": "Flag sources"
        },
        {
            "location": "/api/sources/#flag-sources",
            "text": "Django-Flags provides a means to provide custom flag sources using the  FLAG_SOURCES  setting . Flag sources are classes that provide a  get_flags  method. The  get_flags  method must return a dictionary of flag name keys with a list of  Condition  objects.  from flags.sources import Condition\n\n\nclass CustomFlagSource(object):\n\n    def get_flags(self):\n        flags = {\n            'MY_FLAG': [\n                Condition('parameter', 'enable_my_flag'),\n            ]\n        }\n        return flags",
            "title": "Flag Sources"
        },
        {
            "location": "/api/sources/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/sources/#get_flagssourcesnone",
            "text": "Return a dictionary of all flag names with  Flag  objects that are available in the given  sources . If  sources  is not given, the sources in the  FLAG_SOURCES  setting  are used.",
            "title": "get_flags(sources=None)"
        },
        {
            "location": "/api/sources/#conditioncondition-value-sourcenone-objnone",
            "text": "A simple wrapper around conditions.",
            "title": "Condition(condition, value, source=None, obj=None)"
        },
        {
            "location": "/api/sources/#conditioncheckkwargs",
            "text": "Check the condition against the given keyword arguments.",
            "title": "Condition.check(*kwargs)"
        },
        {
            "location": "/api/sources/#flagname-conditions",
            "text": "A simple wrapper around flags and their conditions.  conditions  is a list of  Condition  objects.",
            "title": "Flag(name, conditions=[])"
        },
        {
            "location": "/api/sources/#flagcheck_statekwargs",
            "text": "Check all of a flag's conditions and return the state based on the given keyword arguments.",
            "title": "Flag.check_state(*kwargs)"
        },
        {
            "location": "/api/state/",
            "text": "Flag state\n\u00b6\n\n\nfrom flags.state import (\n    flag_state,\n    flag_enabled,\n    flag_disabled,\n)\n\n\n\nChecking state\n\u00b6\n\n\nflag_state(flag_name, **kwargs)\n\u00b6\n\n\nReturn the value for the flag (\nTrue\n or \nFalse\n) by passing kwargs to its conditions. If the flag does not exist, this will return \nNone\n so that existence can be introspected but will still evaluate to \nFalse\n.\n\n\nRequiring state\n\u00b6\n\n\nflag_enabled(flag_name, **kwargs)\n\u00b6\n\n\nReturns \nTrue\n if a flag is enabled by passing kwargs to its conditions, otherwise returns \nFalse\n.\n\n\nif flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\")\n\n\n\nflag_disabled(flag_name, **kwargs)\n\u00b6\n\n\nReturns \nTrue\n if a flag is disabled by passing kwargs to its conditions, otherwise returns \nFalse\n.\n\n\nif flag_disabled('MY_FLAG', request=a_request):\n    print(\u201cMy feature flag is disabled\u201d)",
            "title": "Flag state"
        },
        {
            "location": "/api/state/#flag-state",
            "text": "from flags.state import (\n    flag_state,\n    flag_enabled,\n    flag_disabled,\n)",
            "title": "Flag state"
        },
        {
            "location": "/api/state/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/state/#flag_stateflag_name-kwargs",
            "text": "Return the value for the flag ( True  or  False ) by passing kwargs to its conditions. If the flag does not exist, this will return  None  so that existence can be introspected but will still evaluate to  False .",
            "title": "flag_state(flag_name, **kwargs)"
        },
        {
            "location": "/api/state/#requiring-state",
            "text": "",
            "title": "Requiring state"
        },
        {
            "location": "/api/state/#flag_enabledflag_name-kwargs",
            "text": "Returns  True  if a flag is enabled by passing kwargs to its conditions, otherwise returns  False .  if flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\")",
            "title": "flag_enabled(flag_name, **kwargs)"
        },
        {
            "location": "/api/state/#flag_disabledflag_name-kwargs",
            "text": "Returns  True  if a flag is disabled by passing kwargs to its conditions, otherwise returns  False .  if flag_disabled('MY_FLAG', request=a_request):\n    print(\u201cMy feature flag is disabled\u201d)",
            "title": "flag_disabled(flag_name, **kwargs)"
        },
        {
            "location": "/api/decorators/",
            "text": "Flag decorators\n\u00b6\n\n\nDecorators are provided for use with Django views and conditions that take a \nrequest\n argument. The default behavior is to return a 404 if a callable fallback is not given.\n\n\nfrom flags.decorators import (\n    flag_check,\n    flag_required,\n)\n\n\n\nChecking state\n\u00b6\n\n\nflag_check(flag_name, state, fallback=None, **kwargs)\n\u00b6\n\n\nCheck that a given flag has the given state. If the state does not match, perform the fallback.\n\n\nNote\n, because flags that do not exist are taken to be \nFalse\n by default, \n@flag_check('MY_FLAG', False)\n and \n@flag_check('MY_FLAG', None)\n will both succeed if \nMY_FLAG\n does not exist.\n\n\nfrom flags.decorators import flag_check\n\n@flag_check('MY_FLAG', True)\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\n@flag_check('MY_OTHER_FLAG', False)\ndef view_when_flag_is_not_set(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_check('MY_FLAG_WITH_FALLBACK', True, fallback=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')\n\n\n\nRequiring state\n\u00b6\n\n\nflag_required(flag_name, fallback_view=None, pass_if_set=True)\n\u00b6\n\n\nRequire the given flag to be enabled.\n\n\nfrom flags.decorators import flag_required\n\n@flag_required('MY_FLAG')\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_required('MY_FLAG_WITH_FALLBACK', fallback_view=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')",
            "title": "Flag decorators"
        },
        {
            "location": "/api/decorators/#flag-decorators",
            "text": "Decorators are provided for use with Django views and conditions that take a  request  argument. The default behavior is to return a 404 if a callable fallback is not given.  from flags.decorators import (\n    flag_check,\n    flag_required,\n)",
            "title": "Flag decorators"
        },
        {
            "location": "/api/decorators/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/decorators/#flag_checkflag_name-state-fallbacknone-kwargs",
            "text": "Check that a given flag has the given state. If the state does not match, perform the fallback.  Note , because flags that do not exist are taken to be  False  by default,  @flag_check('MY_FLAG', False)  and  @flag_check('MY_FLAG', None)  will both succeed if  MY_FLAG  does not exist.  from flags.decorators import flag_check\n\n@flag_check('MY_FLAG', True)\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\n@flag_check('MY_OTHER_FLAG', False)\ndef view_when_flag_is_not_set(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_check('MY_FLAG_WITH_FALLBACK', True, fallback=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')",
            "title": "flag_check(flag_name, state, fallback=None, **kwargs)"
        },
        {
            "location": "/api/decorators/#requiring-state",
            "text": "",
            "title": "Requiring state"
        },
        {
            "location": "/api/decorators/#flag_requiredflag_name-fallback_viewnone-pass_if_settrue",
            "text": "Require the given flag to be enabled.  from flags.decorators import flag_required\n\n@flag_required('MY_FLAG')\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_required('MY_FLAG_WITH_FALLBACK', fallback_view=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')",
            "title": "flag_required(flag_name, fallback_view=None, pass_if_set=True)"
        },
        {
            "location": "/api/urls/",
            "text": "Flagged URL patterns\n\u00b6\n\n\nFlagged URL patterns are an alternative to \nflagging views with decorators\n.\n\n\nDjango 2.0+\n\u00b6\n\n\nfrom flags.urls import flagged_path, flagged_paths, flagged_re_path, flagged_re_paths\n\n\n\nflagged_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)\n\u00b6\n\n\nflagged_re_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)\n\u00b6\n\n\nMake a URL depend on the state of a feature flag. \n\n\nflagged_path()\n can be used in place of \nDjango's \npath()\n.\n\n\nflagged_re_path()\n can be used in place of \nDjango's \nre_path()\n.\n\n\nThe \nview\n and the \nfallback\n can both be a set of \ninclude()\ned patterns but any matching URL patterns in the includes must match \nexactly\n in terms of regular expression, keyword arguments, and name, otherwise a \n404\n may be unexpectedly raised. \n\n\nIf a \nfallback\n is not given the flagged url will raise a \n404\n if the flag state does not match the required \nstate\n. \n\n\nurlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n    flagged_re_path('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                    view_with_fallback, state=True, fallback=other_view)\n    flagged_path('MY_FLAGGED_INCLUDE', 'myapp/', include('myapp.urls'),\n                 state=True, fallback=other_view)\n    flagged_re_path('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                    state=True, fallback=include('myoldapp.urls'))\n]\n\n\n\nflagged_paths(flag_name, state=True, fallback=None)\n\u00b6\n\n\nflagged_re_paths(flag_name, state=True, fallback=None)\n\u00b6\n\n\nFlag multiple URLs in the same context with a context manager.\n\n\nflagged_paths()\n returns a function that takes the same arguments as \nDjango's \npath()\n and which will flag the pattern's view.\n\n\nflagged_re_paths()\n returns a function that takes the same arguments as \nDjango's \nre_path()\n and which will flag the pattern's view.\n\n\nwith flagged_paths('MY_FLAG') as path:\n    flagged_url_patterns = [\n        path('a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns\n\n\n\nDjango 1.x\n\u00b6\n\n\nfrom flags.urls import flagged_url, flagged_urls\n\n\n\nflagged_url(flag_name, regex, view, kwargs=None, name=None, state=True, fallback=None)\n\u00b6\n\n\nMake a URL depend on the state of a feature flag. \n\n\nflagged_url()\n can be used in place of \nDjango's \nurl()\n.\n\n\nThe \nview\n and the \nfallback\n can both be a set of \ninclude()\ned patterns but any matching URL patterns in the includes must match \nexactly\n in terms of regular expression, keyword arguments, and name, otherwise a \n404\n may be unexpectedly raised. \n\n\nIf a \nfallback\n is not given the flagged url will raise a \n404\n if the flag state does not match the required \nstate\n. \n\n\nurlpatterns = [\n    flagged_url('MY_FLAG', r'a-url/', view_requiring_flag, state=True),\n    flagged_url('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                view_with_fallback, state=True, fallback=other_view)\n    flagged_url('MY_FLAGGED_INCLUDE', '^myapp/', include('myapp.urls'),\n                state=True, fallback=other_view)\n    flagged_url('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                state=True, fallback=include('myoldapp.urls'))\n]\n\n\n\nflagged_urls(flag_name, state=True, fallback=None)\n\u00b6\n\n\nFlag multiple URLs in the same context with a context manager.\n\n\nflagged_urls()\n returns a function that takes the same arguments as \nDjango's \nurl()\n.\n\n\nwith flagged_urls('MY_FLAG') as url:\n    flagged_url_patterns = [\n        url(^'a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns",
            "title": "Flagged URL patterns"
        },
        {
            "location": "/api/urls/#flagged-url-patterns",
            "text": "Flagged URL patterns are an alternative to  flagging views with decorators .",
            "title": "Flagged URL patterns"
        },
        {
            "location": "/api/urls/#django-20",
            "text": "from flags.urls import flagged_path, flagged_paths, flagged_re_path, flagged_re_paths",
            "title": "Django 2.0+"
        },
        {
            "location": "/api/urls/#flagged_pathflag_name-route-view-kwargsnone-namenone-statetrue-fallbacknone",
            "text": "",
            "title": "flagged_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_re_pathflag_name-route-view-kwargsnone-namenone-statetrue-fallbacknone",
            "text": "Make a URL depend on the state of a feature flag.   flagged_path()  can be used in place of  Django's  path() .  flagged_re_path()  can be used in place of  Django's  re_path() .  The  view  and the  fallback  can both be a set of  include() ed patterns but any matching URL patterns in the includes must match  exactly  in terms of regular expression, keyword arguments, and name, otherwise a  404  may be unexpectedly raised.   If a  fallback  is not given the flagged url will raise a  404  if the flag state does not match the required  state .   urlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n    flagged_re_path('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                    view_with_fallback, state=True, fallback=other_view)\n    flagged_path('MY_FLAGGED_INCLUDE', 'myapp/', include('myapp.urls'),\n                 state=True, fallback=other_view)\n    flagged_re_path('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                    state=True, fallback=include('myoldapp.urls'))\n]",
            "title": "flagged_re_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_pathsflag_name-statetrue-fallbacknone",
            "text": "",
            "title": "flagged_paths(flag_name, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_re_pathsflag_name-statetrue-fallbacknone",
            "text": "Flag multiple URLs in the same context with a context manager.  flagged_paths()  returns a function that takes the same arguments as  Django's  path()  and which will flag the pattern's view.  flagged_re_paths()  returns a function that takes the same arguments as  Django's  re_path()  and which will flag the pattern's view.  with flagged_paths('MY_FLAG') as path:\n    flagged_url_patterns = [\n        path('a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns",
            "title": "flagged_re_paths(flag_name, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#django-1x",
            "text": "from flags.urls import flagged_url, flagged_urls",
            "title": "Django 1.x"
        },
        {
            "location": "/api/urls/#flagged_urlflag_name-regex-view-kwargsnone-namenone-statetrue-fallbacknone",
            "text": "Make a URL depend on the state of a feature flag.   flagged_url()  can be used in place of  Django's  url() .  The  view  and the  fallback  can both be a set of  include() ed patterns but any matching URL patterns in the includes must match  exactly  in terms of regular expression, keyword arguments, and name, otherwise a  404  may be unexpectedly raised.   If a  fallback  is not given the flagged url will raise a  404  if the flag state does not match the required  state .   urlpatterns = [\n    flagged_url('MY_FLAG', r'a-url/', view_requiring_flag, state=True),\n    flagged_url('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                view_with_fallback, state=True, fallback=other_view)\n    flagged_url('MY_FLAGGED_INCLUDE', '^myapp/', include('myapp.urls'),\n                state=True, fallback=other_view)\n    flagged_url('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                state=True, fallback=include('myoldapp.urls'))\n]",
            "title": "flagged_url(flag_name, regex, view, kwargs=None, name=None, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_urlsflag_name-statetrue-fallbacknone",
            "text": "Flag multiple URLs in the same context with a context manager.  flagged_urls()  returns a function that takes the same arguments as  Django's  url() .  with flagged_urls('MY_FLAG') as url:\n    flagged_url_patterns = [\n        url(^'a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns",
            "title": "flagged_urls(flag_name, state=True, fallback=None)"
        },
        {
            "location": "/api/django/",
            "text": "Django templates\n\u00b6\n\n\nDjango-Flags provides a template tag library that can be used to evaluate flags in Django templates.\n\n\n{% load feature_flags %}\n\n\n\nChecking state\n\u00b6\n\n\nflag_enabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is enabled, otherwise returns \nFalse\n.\n\n\n{% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nflag_disabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is disabled, otherwise returns \nFalse\n.\n\n\n{% flag_disabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}\n\n\n\nIf a \nrequest\n exists in the current context,\nit will be passed to any conditions that use it.\n\n\nPassing additional arguments\n\u00b6\n\n\nSome conditions take additional keyword arguments.\nFor example, you could pass a \npage\n object:\n\n\n{% flag_enabled 'MY_FLAG_THAT_CHECKS_PAGE' page=page as my_flag %}\n{% if my_flag %}\n  This flag with a condition that uses the page object evaluated to True.\n{% endif %}",
            "title": "Django templates"
        },
        {
            "location": "/api/django/#django-templates",
            "text": "Django-Flags provides a template tag library that can be used to evaluate flags in Django templates.  {% load feature_flags %}",
            "title": "Django templates"
        },
        {
            "location": "/api/django/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/django/#flag_enabled",
            "text": "Returns  True  if a flag is enabled, otherwise returns  False .  {% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}",
            "title": "flag_enabled"
        },
        {
            "location": "/api/django/#flag_disabled",
            "text": "Returns  True  if a flag is disabled, otherwise returns  False .  {% flag_disabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}  If a  request  exists in the current context,\nit will be passed to any conditions that use it.",
            "title": "flag_disabled"
        },
        {
            "location": "/api/django/#passing-additional-arguments",
            "text": "Some conditions take additional keyword arguments.\nFor example, you could pass a  page  object:  {% flag_enabled 'MY_FLAG_THAT_CHECKS_PAGE' page=page as my_flag %}\n{% if my_flag %}\n  This flag with a condition that uses the page object evaluated to True.\n{% endif %}",
            "title": "Passing additional arguments"
        },
        {
            "location": "/api/jinja2/",
            "text": "Jinja2 templates\n\u00b6\n\n\nDjango-Flags provides an extension for adding the template tags to your Jinja2\nbackend configuration to enable the tags to be used in Jinja2 templates.\n\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        ...\n    },\n    {\n        'BACKEND': 'django.template.backends.jinja2.Jinja2',\n        ...\n        'OPTIONS': {\n            'extensions': [\n                ...\n                'flags.jinja2tags.flags',  # add this line to your existing settings\n                ...\n            ],\n        }\n    },\n]\n\n\n\nChecking state\n\u00b6\n\n\nflag_enabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is enabled, otherwise returns \nFalse\n.\n\n\n{% if flag_enabled('MY_FLAG') %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nflag_disabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is disabled to its conditions, otherwise returns \nFalse\n.\n\n\n{% if flag_disabled('MY_FLAG') %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}\n\n\n\nIf a \nrequest\n exists in the current context,\nit will be passed to any conditions that use it.\n\n\nPassing additional arguments\n\u00b6\n\n\nSome conditions take additional keyword arguments.\nFor example, you could pass a \npage\n object:\n\n\n{% if flag_enabled('MY_FLAG_THAT_CHECKS_PAGE', page=page) %}\n  This flag with a condition that uses the page object evaluated to True.\n{% endif %}",
            "title": "Jinja2 templates"
        },
        {
            "location": "/api/jinja2/#jinja2-templates",
            "text": "Django-Flags provides an extension for adding the template tags to your Jinja2\nbackend configuration to enable the tags to be used in Jinja2 templates.  TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        ...\n    },\n    {\n        'BACKEND': 'django.template.backends.jinja2.Jinja2',\n        ...\n        'OPTIONS': {\n            'extensions': [\n                ...\n                'flags.jinja2tags.flags',  # add this line to your existing settings\n                ...\n            ],\n        }\n    },\n]",
            "title": "Jinja2 templates"
        },
        {
            "location": "/api/jinja2/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/jinja2/#flag_enabled",
            "text": "Returns  True  if a flag is enabled, otherwise returns  False .  {% if flag_enabled('MY_FLAG') %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}",
            "title": "flag_enabled"
        },
        {
            "location": "/api/jinja2/#flag_disabled",
            "text": "Returns  True  if a flag is disabled to its conditions, otherwise returns  False .  {% if flag_disabled('MY_FLAG') %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}  If a  request  exists in the current context,\nit will be passed to any conditions that use it.",
            "title": "flag_disabled"
        },
        {
            "location": "/api/jinja2/#passing-additional-arguments",
            "text": "Some conditions take additional keyword arguments.\nFor example, you could pass a  page  object:  {% if flag_enabled('MY_FLAG_THAT_CHECKS_PAGE', page=page) %}\n  This flag with a condition that uses the page object evaluated to True.\n{% endif %}",
            "title": "Passing additional arguments"
        },
        {
            "location": "/api/conditions/",
            "text": "Conditions\n\u00b6\n\n\nConditions are functions that take a configured value and possible keyword arguments and determines whether the given arguments are equivalent to the value. Conditions are registered with a unique name that is exposed to users in Django settings and the Django admin.\n\n\nfrom flags import conditions\n\n\n\nRegistering conditions\n\u00b6\n\n\nconditions.register(condition_name, fn=None)\n\u00b6\n\n\nRegister a new condition, either as a decorator:\n\n\nfrom flags import conditions\n\n@conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)\n\n\n\nOr as a function call:\n\n\ndef path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)\n\nconditions.register('path', fn=path_condition)\n\n\n\nWill raise a \nconditions.DuplicateCondition\n exception if the condition name is already registered.\n\n\nExceptions\n\u00b6\n\n\nconditions.DuplicateCondition\n\u00b6\n\n\nException raised by \nconditions.register\n if the condition name being registered is already registered.\n\n\nconditions.RequiredForCondition\n\u00b6\n\n\nException intended to be raised when a condition is not given a keyword argument it requires for evaluation.\n\n\n@conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    if request is None:\n        raise conditions.RequiredForCondition(\n            \"request is required for condition 'path'\")\n\n    return request.path.startswith(path)",
            "title": "Conditions"
        },
        {
            "location": "/api/conditions/#conditions",
            "text": "Conditions are functions that take a configured value and possible keyword arguments and determines whether the given arguments are equivalent to the value. Conditions are registered with a unique name that is exposed to users in Django settings and the Django admin.  from flags import conditions",
            "title": "Conditions"
        },
        {
            "location": "/api/conditions/#registering-conditions",
            "text": "",
            "title": "Registering conditions"
        },
        {
            "location": "/api/conditions/#conditionsregistercondition_name-fnnone",
            "text": "Register a new condition, either as a decorator:  from flags import conditions\n\n@conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)  Or as a function call:  def path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)\n\nconditions.register('path', fn=path_condition)  Will raise a  conditions.DuplicateCondition  exception if the condition name is already registered.",
            "title": "conditions.register(condition_name, fn=None)"
        },
        {
            "location": "/api/conditions/#exceptions",
            "text": "",
            "title": "Exceptions"
        },
        {
            "location": "/api/conditions/#conditionsduplicatecondition",
            "text": "Exception raised by  conditions.register  if the condition name being registered is already registered.",
            "title": "conditions.DuplicateCondition"
        },
        {
            "location": "/api/conditions/#conditionsrequiredforcondition",
            "text": "Exception intended to be raised when a condition is not given a keyword argument it requires for evaluation.  @conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    if request is None:\n        raise conditions.RequiredForCondition(\n            \"request is required for condition 'path'\")\n\n    return request.path.startswith(path)",
            "title": "conditions.RequiredForCondition"
        },
        {
            "location": "/releasenotes/",
            "text": "Release Notes\n\u00b6\n\n\n4.0\n\u00b6\n\n\nWhat's new?\n\u00b6\n\n\n\n\nThe template functions \nflag_enabled\n and \nflag_disabled\n in both \nDjango\n and \nJinja2\n templates now support taking keyword arguments that could be used by \ncustom conditions\n.\n\n\nJinja2 template functions are now available via a Jinja2 extension that can be \nincluded in \nsettings.py\n. \n\n\nThe optional \nflags.middleware.FlagConditionsMiddleware\n has been added to ensure that all feature flag checks throughout single request cycle use the same flag conditions.\n\n\nSupport for specifying the \nsource of feature flags in \nsettings.py\n has been added to allow further customization and the potential to limit flags to settings or database-only.\n\n\nThe \"user\" condition now supports custom user models. (\n@callorico\n)\n\n\n\n\nUpgrading\n\u00b6\n\n\nDjango-Flags 4.0 introduces backwards-incompatible changes for users of Jinja2 templates.\n\n\nPreviously Django-Flags provided \nflags.template_functions.flag_enabled\n and \nflags.template_functions.flag_disabled\n functions that had to be registered in the Jinja2 environment downstream. The Django-Flags documentation recommended doing so in \njinja2.Environment.globals.update()\n. \nflags.template_functions\n has been removed in Django-Flags 4.0.\n\n\nJinja2 function registration is now handled by a \nflags.jinja2tags.flags\n Jinja2 extension. To use Django-Flags 4.0 with Jinja2 templates, the \nTEMPLATES\n setting in \nsettings.py\n should to be modified to include the extension:\n\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.jinja2.Jinja2',\n        ...\n        'OPTIONS': {\n            'extensions': [\n                ...\n                'flags.jinja2tags.flags',  # add this line to your existing settings\n                ...\n            ],\n        }\n    },\n] \n\n\n\n3.0.2\n\u00b6\n\n\nWhat's new?\n\u00b6\n\n\n\n\nRequests are now optional the \nflag_enabled\n and \nflag_disabled\n template tags.\n\n\nFlag state form conditions are now bound when the form is created to ensure all custom conditions are available on the form. (\n@callorico\n)\n\n\n\n\n3.0.1\n\u00b6\n\n\nWhat's new?\n\u00b6\n\n\n\n\nDjango 2.1 is now supported.\n\n\n\n\n3.0\n\u00b6\n\n\nDjango-Flags is a fork of the Django-only components of the \nWagtail-Flags\n feature flag library. This is the initial release.",
            "title": "Release notes"
        },
        {
            "location": "/releasenotes/#release-notes",
            "text": "",
            "title": "Release Notes"
        },
        {
            "location": "/releasenotes/#40",
            "text": "",
            "title": "4.0"
        },
        {
            "location": "/releasenotes/#whats-new",
            "text": "The template functions  flag_enabled  and  flag_disabled  in both  Django  and  Jinja2  templates now support taking keyword arguments that could be used by  custom conditions .  Jinja2 template functions are now available via a Jinja2 extension that can be  included in  settings.py .   The optional  flags.middleware.FlagConditionsMiddleware  has been added to ensure that all feature flag checks throughout single request cycle use the same flag conditions.  Support for specifying the  source of feature flags in  settings.py  has been added to allow further customization and the potential to limit flags to settings or database-only.  The \"user\" condition now supports custom user models. ( @callorico )",
            "title": "What's new?"
        },
        {
            "location": "/releasenotes/#upgrading",
            "text": "Django-Flags 4.0 introduces backwards-incompatible changes for users of Jinja2 templates.  Previously Django-Flags provided  flags.template_functions.flag_enabled  and  flags.template_functions.flag_disabled  functions that had to be registered in the Jinja2 environment downstream. The Django-Flags documentation recommended doing so in  jinja2.Environment.globals.update() .  flags.template_functions  has been removed in Django-Flags 4.0.  Jinja2 function registration is now handled by a  flags.jinja2tags.flags  Jinja2 extension. To use Django-Flags 4.0 with Jinja2 templates, the  TEMPLATES  setting in  settings.py  should to be modified to include the extension:  TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.jinja2.Jinja2',\n        ...\n        'OPTIONS': {\n            'extensions': [\n                ...\n                'flags.jinja2tags.flags',  # add this line to your existing settings\n                ...\n            ],\n        }\n    },\n]",
            "title": "Upgrading"
        },
        {
            "location": "/releasenotes/#302",
            "text": "",
            "title": "3.0.2"
        },
        {
            "location": "/releasenotes/#whats-new_1",
            "text": "Requests are now optional the  flag_enabled  and  flag_disabled  template tags.  Flag state form conditions are now bound when the form is created to ensure all custom conditions are available on the form. ( @callorico )",
            "title": "What's new?"
        },
        {
            "location": "/releasenotes/#301",
            "text": "",
            "title": "3.0.1"
        },
        {
            "location": "/releasenotes/#whats-new_2",
            "text": "Django 2.1 is now supported.",
            "title": "What's new?"
        },
        {
            "location": "/releasenotes/#30",
            "text": "Django-Flags is a fork of the Django-only components of the  Wagtail-Flags  feature flag library. This is the initial release.",
            "title": "3.0"
        }
    ]
}