{
    "docs": [
        {
            "location": "/",
            "text": "Django-Flags\n\u00b6\n\n\nFeature flags allow you to toggle functionality in both Django code and the Django templates based on configurable conditions. Flags can be useful for staging feature deployments, for A/B testing, or for any time you need an on/off switch for blocks of code. The toggle can be by date, user, URL value, or a number of \nother conditions\n, editable in the admin or in definable in settings.\n\n\nDependencies\n\u00b6\n\n\n\n\nDjango 1.8+ (including Django 2.0)\n\n\nPython 2.7+, 3.6+\n\n\n\n\nInstallation\n\u00b6\n\n\nFirst, install django-flags:\n\n\npip install django-flags\n\n\n\nThen add \nflags\n as an installed app in your Django \nsettings.py\n:\n\n\nINSTALLED_APPS = (\n    ...\n    'flags',\n    ...\n)\n\n\n\nConcepts\n\u00b6\n\n\nFeature flags in Django-Flags are identified by simple strings that are enabled when the conditions they are associated with are met. These flags can be used to wrap code and template content that should only be used when a flag is enabled or disabled.\n\n\nConditions determine whether a flag is enabled or disabled by comparing a defined expected value of some kind with the value at the time the flag is checked. In many cases, the flag is checked during a request, and some piece of the request's metadata is what is compared. For example, a feature flag that is enabled for a specific user would be enabled if the request's user matches the condition's user.\n\n\nQuickstart\n\u00b6\n\n\nTo use Django-Flags you first need to define the flag, use the flag, and define conditions for the flag to be enabled.\n\n\nFirst, define the flag in Django \nsettings.py\n:\n\n\nFLAGS = {\n    'MY_FLAG': {}\n}\n\n\n\nThen use the flag in a Django template (\nmytemplate.html\n):\n\n\n{% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n\n{% if my_flag %}\n  <div class=\"flagged-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nConfigure a URL for that template (\nurls.py\n):\n\n\nDjango 2.0:\n\n\nfrom django.urls import path\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    path(r'mypage/', TemplateView.as_view(template_name='mytemplate.html')),\n]\n\n\n\nDjango 1.x:\n\n\nfrom django.conf.urls import url\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    url(r'^mypage/$', TemplateView.as_view(template_name='mytemplate.html')),\n]\n\n\n\nThen in the Django admin add conditions for the flag in \"Django Flags\", \"Flag states\":\n\n\n\n\nThen visiting the URL \n/mypage?enable_my_flag=True\n should show you the flagged \n<div>\n in the template.",
            "title": "Getting started"
        },
        {
            "location": "/#django-flags",
            "text": "Feature flags allow you to toggle functionality in both Django code and the Django templates based on configurable conditions. Flags can be useful for staging feature deployments, for A/B testing, or for any time you need an on/off switch for blocks of code. The toggle can be by date, user, URL value, or a number of  other conditions , editable in the admin or in definable in settings.",
            "title": "Django-Flags"
        },
        {
            "location": "/#dependencies",
            "text": "Django 1.8+ (including Django 2.0)  Python 2.7+, 3.6+",
            "title": "Dependencies"
        },
        {
            "location": "/#installation",
            "text": "First, install django-flags:  pip install django-flags  Then add  flags  as an installed app in your Django  settings.py :  INSTALLED_APPS = (\n    ...\n    'flags',\n    ...\n)",
            "title": "Installation"
        },
        {
            "location": "/#concepts",
            "text": "Feature flags in Django-Flags are identified by simple strings that are enabled when the conditions they are associated with are met. These flags can be used to wrap code and template content that should only be used when a flag is enabled or disabled.  Conditions determine whether a flag is enabled or disabled by comparing a defined expected value of some kind with the value at the time the flag is checked. In many cases, the flag is checked during a request, and some piece of the request's metadata is what is compared. For example, a feature flag that is enabled for a specific user would be enabled if the request's user matches the condition's user.",
            "title": "Concepts"
        },
        {
            "location": "/#quickstart",
            "text": "To use Django-Flags you first need to define the flag, use the flag, and define conditions for the flag to be enabled.  First, define the flag in Django  settings.py :  FLAGS = {\n    'MY_FLAG': {}\n}  Then use the flag in a Django template ( mytemplate.html ):  {% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n\n{% if my_flag %}\n  <div class=\"flagged-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}  Configure a URL for that template ( urls.py ):  Django 2.0:  from django.urls import path\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    path(r'mypage/', TemplateView.as_view(template_name='mytemplate.html')),\n]  Django 1.x:  from django.conf.urls import url\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    url(r'^mypage/$', TemplateView.as_view(template_name='mytemplate.html')),\n]  Then in the Django admin add conditions for the flag in \"Django Flags\", \"Flag states\":   Then visiting the URL  /mypage?enable_my_flag=True  should show you the flagged  <div>  in the template.",
            "title": "Quickstart"
        },
        {
            "location": "/usage/",
            "text": "Usage guide\n\u00b6\n\n\nDefining flags\n\u00b6\n\n\nFlags are defined in Django settings with the conditions in which they are enabled.\n\n\nFLAGS = {\n  'FLAG_WITH_EMPTY_CONDITIONS': {}\n  'MY_FLAG': {\n    'condition name': 'value flag is expected to match to be enabled',\n    'user': 'lady.liberty'\n  }\n}\n\n\n\nThe set of conditions can be none (flag will never be enabled), one (only condition that has to be met for the flag to be enabled), or many (all have to be met for the flag to be enabled).\n\n\nAdditional conditions can be added in the Django admin for any defined flag (illustrated in \nUsage\n). Conditions added in the Django admin can be changed without restarting Django, conditions defined in \nsettings.py\n cannot. See below \nfor a list of built-in conditions\n.\n\n\nUsing flags in code\n\u00b6\n\n\nFlags can be used in Python code:\n\n\nfrom flags.state import flag_enabled\n\nif flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\") \n\n\n\nDjango templates:\n\n\n{% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nJinja2 templates (after \nadding \nflag_enabled\n to the Jinja2 environment\n):\n\n\n{% if flag_enabled('MY_FLAG', request) %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nDjango 2.0 \nurls.py\n:\n\n\nfrom flags.urls import flagged_path\n\nurlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n]\n\n\n\nAnd Django 1.x \nurls.py\n:\n\n\nfrom flags.urls import flagged_url\n\nurlpatterns = [\n    flagged_url('MY_FLAG', r'^a-url$', view_requiring_flag, state=True),\n]\n\n\n\nSee the \nAPI documentation below\n for more details and examples.",
            "title": "Usage guide"
        },
        {
            "location": "/usage/#usage-guide",
            "text": "",
            "title": "Usage guide"
        },
        {
            "location": "/usage/#defining-flags",
            "text": "Flags are defined in Django settings with the conditions in which they are enabled.  FLAGS = {\n  'FLAG_WITH_EMPTY_CONDITIONS': {}\n  'MY_FLAG': {\n    'condition name': 'value flag is expected to match to be enabled',\n    'user': 'lady.liberty'\n  }\n}  The set of conditions can be none (flag will never be enabled), one (only condition that has to be met for the flag to be enabled), or many (all have to be met for the flag to be enabled).  Additional conditions can be added in the Django admin for any defined flag (illustrated in  Usage ). Conditions added in the Django admin can be changed without restarting Django, conditions defined in  settings.py  cannot. See below  for a list of built-in conditions .",
            "title": "Defining flags"
        },
        {
            "location": "/usage/#using-flags-in-code",
            "text": "Flags can be used in Python code:  from flags.state import flag_enabled\n\nif flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\")   Django templates:  {% load feature_flags %}\n{% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}  Jinja2 templates (after  adding  flag_enabled  to the Jinja2 environment ):  {% if flag_enabled('MY_FLAG', request) %}\n  <div>\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}  Django 2.0  urls.py :  from flags.urls import flagged_path\n\nurlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n]  And Django 1.x  urls.py :  from flags.urls import flagged_url\n\nurlpatterns = [\n    flagged_url('MY_FLAG', r'^a-url$', view_requiring_flag, state=True),\n]  See the  API documentation below  for more details and examples.",
            "title": "Using flags in code"
        },
        {
            "location": "/conditions/",
            "text": "Built-in conditions\n\u00b6\n\n\nDjango-Flags comes with the following conditions built-in:\n\n\nboolean\n\u00b6\n\n\nA simple boolean true/false intended to enable or disable a flag explicitly. The state of the flag evaluates to the value of the boolean condition.\n\n\nFLAGS = {'MY_FLAG': {'boolean': True}}\n\n\n\nuser\n\u00b6\n\n\nAllows a flag to be enabled for the username given as the condition's value.\n\n\nFLAGS = {'MY_FLAG': {'user': 'jane.doe'}}\n\n\n\nanonymous\n\u00b6\n\n\nAllows a flag to be either enabled or disabled depending on the condition's boolean value.\n\n\nFLAGS = {'MY_FLAG': {'anonymous: False}}\n\n\n\nparameter\n\u00b6\n\n\nAllows a flag to be enabled based on a GET parameter with the name given as the condition's value.\n\n\nFLAGS = {'MY_FLAG': {'parameter': 'my_flag_param'}}\n\n\n\npath\n\u00b6\n\n\nAllows a flag to be enabled if the request's path matches the condition value.\n\n\nFLAGS = {'MY_FLAG': {'path': '/flagged/path'}}\n\n\n\nafter date\n\u00b6\n\n\nAllows a flag to be enabled after a given date (and time) given in \nISO 8601 format\n. The time must be specified either in UTC or as an offset from UTC.\n\n\nFLAGS = {'MY_FLAG': {'after date': '2017-06-01T12:00Z'}}\n\n\n\nCustom conditions\n\u00b6\n\n\nCustom conditions can be created and registered for use using the \nconditions API\n.",
            "title": "Built-in conditions"
        },
        {
            "location": "/conditions/#built-in-conditions",
            "text": "Django-Flags comes with the following conditions built-in:",
            "title": "Built-in conditions"
        },
        {
            "location": "/conditions/#boolean",
            "text": "A simple boolean true/false intended to enable or disable a flag explicitly. The state of the flag evaluates to the value of the boolean condition.  FLAGS = {'MY_FLAG': {'boolean': True}}",
            "title": "boolean"
        },
        {
            "location": "/conditions/#user",
            "text": "Allows a flag to be enabled for the username given as the condition's value.  FLAGS = {'MY_FLAG': {'user': 'jane.doe'}}",
            "title": "user"
        },
        {
            "location": "/conditions/#anonymous",
            "text": "Allows a flag to be either enabled or disabled depending on the condition's boolean value.  FLAGS = {'MY_FLAG': {'anonymous: False}}",
            "title": "anonymous"
        },
        {
            "location": "/conditions/#parameter",
            "text": "Allows a flag to be enabled based on a GET parameter with the name given as the condition's value.  FLAGS = {'MY_FLAG': {'parameter': 'my_flag_param'}}",
            "title": "parameter"
        },
        {
            "location": "/conditions/#path",
            "text": "Allows a flag to be enabled if the request's path matches the condition value.  FLAGS = {'MY_FLAG': {'path': '/flagged/path'}}",
            "title": "path"
        },
        {
            "location": "/conditions/#after-date",
            "text": "Allows a flag to be enabled after a given date (and time) given in  ISO 8601 format . The time must be specified either in UTC or as an offset from UTC.  FLAGS = {'MY_FLAG': {'after date': '2017-06-01T12:00Z'}}",
            "title": "after date"
        },
        {
            "location": "/conditions/#custom-conditions",
            "text": "Custom conditions can be created and registered for use using the  conditions API .",
            "title": "Custom conditions"
        },
        {
            "location": "/api/state/",
            "text": "Flag state\n\u00b6\n\n\nfrom flags.state import (\n    flag_state,\n    flag_enabled,\n    flag_disabled,\n)\n\n\n\nChecking state\n\u00b6\n\n\nflag_state(flag_name, **kwargs)\n\u00b6\n\n\nReturn the value for the flag (\nTrue\n or \nFalse\n) by passing kwargs to its conditions.\n\n\nRequiring state\n\u00b6\n\n\nflag_enabled(flag_name, **kwargs)\n\u00b6\n\n\nReturns \nTrue\n if a flag is enabled by passing kwargs to its conditions, otherwise returns \nFalse\n.\n\n\nif flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\")\n\n\n\nflag_disabled(flag_name, **kwargs)\n\u00b6\n\n\nReturns \nTrue\n if a flag is disabled by passing kwargs to its conditions, otherwise returns \nFalse\n.\n\n\nif flag_disabled('MY_FLAG', request=a_request):\n    print(\u201cMy feature flag is disabled\u201d)",
            "title": "Flag state"
        },
        {
            "location": "/api/state/#flag-state",
            "text": "from flags.state import (\n    flag_state,\n    flag_enabled,\n    flag_disabled,\n)",
            "title": "Flag state"
        },
        {
            "location": "/api/state/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/state/#flag_stateflag_name-kwargs",
            "text": "Return the value for the flag ( True  or  False ) by passing kwargs to its conditions.",
            "title": "flag_state(flag_name, **kwargs)"
        },
        {
            "location": "/api/state/#requiring-state",
            "text": "",
            "title": "Requiring state"
        },
        {
            "location": "/api/state/#flag_enabledflag_name-kwargs",
            "text": "Returns  True  if a flag is enabled by passing kwargs to its conditions, otherwise returns  False .  if flag_enabled('MY_FLAG', request=a_request):\n    print(\"My feature flag is enabled\")",
            "title": "flag_enabled(flag_name, **kwargs)"
        },
        {
            "location": "/api/state/#flag_disabledflag_name-kwargs",
            "text": "Returns  True  if a flag is disabled by passing kwargs to its conditions, otherwise returns  False .  if flag_disabled('MY_FLAG', request=a_request):\n    print(\u201cMy feature flag is disabled\u201d)",
            "title": "flag_disabled(flag_name, **kwargs)"
        },
        {
            "location": "/api/decorators/",
            "text": "Flag decorators\n\u00b6\n\n\nDecorators are provided for use with Django views and conditions that take a \nrequest\n argument. The default behavior is to return a 404 if a callable fallback is not given.\n\n\nfrom flags.decorators import (\n    flag_check,\n    flag_required,\n)\n\n\n\nChecking state\n\u00b6\n\n\nflag_check(flag_name, state, fallback=None, **kwargs)\n\u00b6\n\n\nCheck that a given flag has the given state. If the state does not match, perform the fallback.\n\n\nNote\n, because flags that do not exist are taken to be \nFalse\n by default, \n@flag_check('MY_FLAG', False)\n and \n@flag_check('MY_FLAG', None)\n will both succeed if \nMY_FLAG\n does not exist.\n\n\nfrom flags.decorators import flag_check\n\n@flag_check('MY_FLAG', True)\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\n@flag_check('MY_OTHER_FLAG', False)\ndef view_when_flag_is_not_set(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_check('MY_FLAG_WITH_FALLBACK', True, fallback=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')\n\n\n\nRequiring state\n\u00b6\n\n\nflag_required(flag_name, fallback_view=None, pass_if_set=True)\n\u00b6\n\n\nRequire the given flag to be enabled.\n\n\nfrom flags.decorators import flag_required\n\n@flag_required('MY_FLAG')\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_required('MY_FLAG_WITH_FALLBACK', fallback_view=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')",
            "title": "Flag decorators"
        },
        {
            "location": "/api/decorators/#flag-decorators",
            "text": "Decorators are provided for use with Django views and conditions that take a  request  argument. The default behavior is to return a 404 if a callable fallback is not given.  from flags.decorators import (\n    flag_check,\n    flag_required,\n)",
            "title": "Flag decorators"
        },
        {
            "location": "/api/decorators/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/decorators/#flag_checkflag_name-state-fallbacknone-kwargs",
            "text": "Check that a given flag has the given state. If the state does not match, perform the fallback.  Note , because flags that do not exist are taken to be  False  by default,  @flag_check('MY_FLAG', False)  and  @flag_check('MY_FLAG', None)  will both succeed if  MY_FLAG  does not exist.  from flags.decorators import flag_check\n\n@flag_check('MY_FLAG', True)\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\n@flag_check('MY_OTHER_FLAG', False)\ndef view_when_flag_is_not_set(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_check('MY_FLAG_WITH_FALLBACK', True, fallback=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')",
            "title": "flag_check(flag_name, state, fallback=None, **kwargs)"
        },
        {
            "location": "/api/decorators/#requiring-state",
            "text": "",
            "title": "Requiring state"
        },
        {
            "location": "/api/decorators/#flag_requiredflag_name-fallback_viewnone-pass_if_settrue",
            "text": "Require the given flag to be enabled.  from flags.decorators import flag_required\n\n@flag_required('MY_FLAG')\ndef view_requiring_flag(request):\n    return HttpResponse('flag was set')\n\ndef other_view(request):\n    return HttpResponse('flag was not set')\n\n@flag_required('MY_FLAG_WITH_FALLBACK', fallback_view=other_view)\ndef view_with_fallback(request):\n    return HttpResponse('flag was set')",
            "title": "flag_required(flag_name, fallback_view=None, pass_if_set=True)"
        },
        {
            "location": "/api/urls/",
            "text": "Flagged URL patterns\n\u00b6\n\n\nFlagged URL patterns are an alternative to \nflagging views with decorators\n.\n\n\nDjango 2.0+\n\u00b6\n\n\nfrom flags.urls import flagged_path, flagged_paths, flagged_re_path, flagged_re_paths\n\n\n\nflagged_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)\n\u00b6\n\n\nflagged_re_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)\n\u00b6\n\n\nMake a URL depend on the state of a feature flag. \n\n\nflagged_path()\n can be used in place of \nDjango's \npath()\n.\n\n\nflagged_re_path()\n can be used in place of \nDjango's \nre_path()\n.\n\n\nThe \nview\n and the \nfallback\n can both be a set of \ninclude()\ned patterns but any matching URL patterns in the includes must match \nexactly\n in terms of regular expression, keyword arguments, and name, otherwise a \n404\n may be unexpectedly raised. \n\n\nIf a \nfallback\n is not given the flagged url will raise a \n404\n if the flag state does not match the required \nstate\n. \n\n\nurlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n    flagged_re_path('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                    view_with_fallback, state=True, fallback=other_view)\n    flagged_path('MY_FLAGGED_INCLUDE', 'myapp/', include('myapp.urls'),\n                 state=True, fallback=other_view)\n    flagged_re_path('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                    state=True, fallback=include('myoldapp.urls'))\n]\n\n\n\nflagged_paths(flag_name, state=True, fallback=None)\n\u00b6\n\n\nflagged_re_paths(flag_name, state=True, fallback=None)\n\u00b6\n\n\nFlag multiple URLs in the same context with a context manager.\n\n\nflagged_paths()\n returns a function that takes the same arguments as \nDjango's \npath()\n and which will flag the pattern's view.\n\n\nflagged_re_paths()\n returns a function that takes the same arguments as \nDjango's \nre_path()\n and which will flag the pattern's view.\n\n\nwith flagged_paths('MY_FLAG') as path:\n    flagged_url_patterns = [\n        path('a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns\n\n\n\nDjango 1.x\n\u00b6\n\n\nfrom flags.urls import flagged_url, flagged_urls\n\n\n\nflagged_url(flag_name, regex, view, kwargs=None, name=None, state=True, fallback=None)\n\u00b6\n\n\nMake a URL depend on the state of a feature flag. \n\n\nflagged_url()\n can be used in place of \nDjango's \nurl()\n.\n\n\nThe \nview\n and the \nfallback\n can both be a set of \ninclude()\ned patterns but any matching URL patterns in the includes must match \nexactly\n in terms of regular expression, keyword arguments, and name, otherwise a \n404\n may be unexpectedly raised. \n\n\nIf a \nfallback\n is not given the flagged url will raise a \n404\n if the flag state does not match the required \nstate\n. \n\n\nurlpatterns = [\n    flagged_url('MY_FLAG', r'a-url/', view_requiring_flag, state=True),\n    flagged_url('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                view_with_fallback, state=True, fallback=other_view)\n    flagged_url('MY_FLAGGED_INCLUDE', '^myapp/', include('myapp.urls'),\n                state=True, fallback=other_view)\n    flagged_url('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                state=True, fallback=include('myoldapp.urls'))\n]\n\n\n\nflagged_urls(flag_name, state=True, fallback=None)\n\u00b6\n\n\nFlag multiple URLs in the same context with a context manager.\n\n\nflagged_urls()\n returns a function that takes the same arguments as \nDjango's \nurl()\n.\n\n\nwith flagged_urls('MY_FLAG') as url:\n    flagged_url_patterns = [\n        url(^'a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns",
            "title": "Flagged URL patterns"
        },
        {
            "location": "/api/urls/#flagged-url-patterns",
            "text": "Flagged URL patterns are an alternative to  flagging views with decorators .",
            "title": "Flagged URL patterns"
        },
        {
            "location": "/api/urls/#django-20",
            "text": "from flags.urls import flagged_path, flagged_paths, flagged_re_path, flagged_re_paths",
            "title": "Django 2.0+"
        },
        {
            "location": "/api/urls/#flagged_pathflag_name-route-view-kwargsnone-namenone-statetrue-fallbacknone",
            "text": "",
            "title": "flagged_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_re_pathflag_name-route-view-kwargsnone-namenone-statetrue-fallbacknone",
            "text": "Make a URL depend on the state of a feature flag.   flagged_path()  can be used in place of  Django's  path() .  flagged_re_path()  can be used in place of  Django's  re_path() .  The  view  and the  fallback  can both be a set of  include() ed patterns but any matching URL patterns in the includes must match  exactly  in terms of regular expression, keyword arguments, and name, otherwise a  404  may be unexpectedly raised.   If a  fallback  is not given the flagged url will raise a  404  if the flag state does not match the required  state .   urlpatterns = [\n    flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True),\n    flagged_re_path('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                    view_with_fallback, state=True, fallback=other_view)\n    flagged_path('MY_FLAGGED_INCLUDE', 'myapp/', include('myapp.urls'),\n                 state=True, fallback=other_view)\n    flagged_re_path('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                    state=True, fallback=include('myoldapp.urls'))\n]",
            "title": "flagged_re_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_pathsflag_name-statetrue-fallbacknone",
            "text": "",
            "title": "flagged_paths(flag_name, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_re_pathsflag_name-statetrue-fallbacknone",
            "text": "Flag multiple URLs in the same context with a context manager.  flagged_paths()  returns a function that takes the same arguments as  Django's  path()  and which will flag the pattern's view.  flagged_re_paths()  returns a function that takes the same arguments as  Django's  re_path()  and which will flag the pattern's view.  with flagged_paths('MY_FLAG') as path:\n    flagged_url_patterns = [\n        path('a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns",
            "title": "flagged_re_paths(flag_name, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#django-1x",
            "text": "from flags.urls import flagged_url, flagged_urls",
            "title": "Django 1.x"
        },
        {
            "location": "/api/urls/#flagged_urlflag_name-regex-view-kwargsnone-namenone-statetrue-fallbacknone",
            "text": "Make a URL depend on the state of a feature flag.   flagged_url()  can be used in place of  Django's  url() .  The  view  and the  fallback  can both be a set of  include() ed patterns but any matching URL patterns in the includes must match  exactly  in terms of regular expression, keyword arguments, and name, otherwise a  404  may be unexpectedly raised.   If a  fallback  is not given the flagged url will raise a  404  if the flag state does not match the required  state .   urlpatterns = [\n    flagged_url('MY_FLAG', r'a-url/', view_requiring_flag, state=True),\n    flagged_url('MY_FLAG_WITH_FALLBACK', r'^another-url$', \n                view_with_fallback, state=True, fallback=other_view)\n    flagged_url('MY_FLAGGED_INCLUDE', '^myapp/', include('myapp.urls'),\n                state=True, fallback=other_view)\n    flagged_url('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'),\n                state=True, fallback=include('myoldapp.urls'))\n]",
            "title": "flagged_url(flag_name, regex, view, kwargs=None, name=None, state=True, fallback=None)"
        },
        {
            "location": "/api/urls/#flagged_urlsflag_name-statetrue-fallbacknone",
            "text": "Flag multiple URLs in the same context with a context manager.  flagged_urls()  returns a function that takes the same arguments as  Django's  url() .  with flagged_urls('MY_FLAG') as url:\n    flagged_url_patterns = [\n        url(^'a-url/', view_requiring_flag),\n    ]\n\nurlpatterns = urlpatterns + flagged_url_patterns",
            "title": "flagged_urls(flag_name, state=True, fallback=None)"
        },
        {
            "location": "/api/django/",
            "text": "Django templates\n\u00b6\n\n\nDjango-Flags provides a template tag library that can be used to evaluate flags in Django templates.\n\n\n{% load feature_flags %}\n\n\n\nChecking state\n\u00b6\n\n\nflag_enabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is enabled by passing the current request to its conditions, otherwise returns \nFalse\n.\n\n\n{% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nflag_disabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is disabled by passing the current request to its conditions, otherwise returns \nFalse\n.\n\n\n{% flag_disabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}",
            "title": "Django templates"
        },
        {
            "location": "/api/django/#django-templates",
            "text": "Django-Flags provides a template tag library that can be used to evaluate flags in Django templates.  {% load feature_flags %}",
            "title": "Django templates"
        },
        {
            "location": "/api/django/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/django/#flag_enabled",
            "text": "Returns  True  if a flag is enabled by passing the current request to its conditions, otherwise returns  False .  {% flag_enabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}",
            "title": "flag_enabled"
        },
        {
            "location": "/api/django/#flag_disabled",
            "text": "Returns  True  if a flag is disabled by passing the current request to its conditions, otherwise returns  False .  {% flag_disabled 'MY_FLAG' as my_flag %}\n{% if my_flag %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}",
            "title": "flag_disabled"
        },
        {
            "location": "/api/jinja2/",
            "text": "Jinja2 templates\n\u00b6\n\n\nDjango-Flags provides template functions that can be added to a Jinja2 environment and subsequently used in templates.\n\n\nfrom flags.template_functions import (\n    flag_enabled,\n    flag_disabled\n)\nfrom jinja2 import Environment\n\n...\n\nenv = Environment(\u2026)\nenv.globals.update(\n    flag_enabled=flag_enabled,\n    flag_disabled=flag_disabled\n)\n\n\n\nChecking state\n\u00b6\n\n\nflag_enabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is enabled by for the given request, otherwise returns \nFalse\n.\n\n\n{% if flag_enabled('MY_FLAG', request) %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}\n\n\n\nflag_disabled\n\u00b6\n\n\nReturns \nTrue\n if a flag is disabled by passing the current request to its conditions, otherwise returns \nFalse\n.\nReturns \nTrue\n if a flag is disabled by for the given request, otherwise returns \nFalse\n.\n\n\n{% if flag_disabled('MY_FLAG', request) %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}",
            "title": "Jinja2 templates"
        },
        {
            "location": "/api/jinja2/#jinja2-templates",
            "text": "Django-Flags provides template functions that can be added to a Jinja2 environment and subsequently used in templates.  from flags.template_functions import (\n    flag_enabled,\n    flag_disabled\n)\nfrom jinja2 import Environment\n\n...\n\nenv = Environment(\u2026)\nenv.globals.update(\n    flag_enabled=flag_enabled,\n    flag_disabled=flag_disabled\n)",
            "title": "Jinja2 templates"
        },
        {
            "location": "/api/jinja2/#checking-state",
            "text": "",
            "title": "Checking state"
        },
        {
            "location": "/api/jinja2/#flag_enabled",
            "text": "Returns  True  if a flag is enabled by for the given request, otherwise returns  False .  {% if flag_enabled('MY_FLAG', request) %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag.   \n  </div>\n{% endif %}",
            "title": "flag_enabled"
        },
        {
            "location": "/api/jinja2/#flag_disabled",
            "text": "Returns  True  if a flag is disabled by passing the current request to its conditions, otherwise returns  False .\nReturns  True  if a flag is disabled by for the given request, otherwise returns  False .  {% if flag_disabled('MY_FLAG', request) %}\n  <div class=\"m-global-banner\">\n    I\u2019m the result of a feature flag that is not enabled.\n  </div>\n{% endif %}",
            "title": "flag_disabled"
        },
        {
            "location": "/api/conditions/",
            "text": "Conditions\n\u00b6\n\n\nConditions are functions that take a configured value and possible keyword arguments and determines whether the given arguments are equivalent to the value. Conditions are registered with a unique name that is exposed to users in Django settings and the Django admin.\n\n\nfrom flags import conditions\n\n\n\nRegistering conditions\n\u00b6\n\n\nconditions.register(condition_name, fn=None)\n\u00b6\n\n\nRegister a new condition, either as a decorator:\n\n\nfrom flags import conditions\n\n@conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)\n\n\n\nOr as a function call:\n\n\ndef path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)\n\nconditions.register('path', fn=path_condition)\n\n\n\nExceptions\n\u00b6\n\n\nconditions.RequiredForCondition\n\u00b6\n\n\nException intended to be raised when a condition is not given a keyword argument it requires for evaluation.\n\n\n@conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    if request is None:\n        raise conditions.RequiredForCondition(\n            \"request is required for condition 'path'\")\n\n    return request.path.startswith(path)",
            "title": "Conditions"
        },
        {
            "location": "/api/conditions/#conditions",
            "text": "Conditions are functions that take a configured value and possible keyword arguments and determines whether the given arguments are equivalent to the value. Conditions are registered with a unique name that is exposed to users in Django settings and the Django admin.  from flags import conditions",
            "title": "Conditions"
        },
        {
            "location": "/api/conditions/#registering-conditions",
            "text": "",
            "title": "Registering conditions"
        },
        {
            "location": "/api/conditions/#conditionsregistercondition_name-fnnone",
            "text": "Register a new condition, either as a decorator:  from flags import conditions\n\n@conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)  Or as a function call:  def path_condition(path, request=None, **kwargs):\n    return request.path.startswith(path)\n\nconditions.register('path', fn=path_condition)",
            "title": "conditions.register(condition_name, fn=None)"
        },
        {
            "location": "/api/conditions/#exceptions",
            "text": "",
            "title": "Exceptions"
        },
        {
            "location": "/api/conditions/#conditionsrequiredforcondition",
            "text": "Exception intended to be raised when a condition is not given a keyword argument it requires for evaluation.  @conditions.register('path')\ndef path_condition(path, request=None, **kwargs):\n    if request is None:\n        raise conditions.RequiredForCondition(\n            \"request is required for condition 'path'\")\n\n    return request.path.startswith(path)",
            "title": "conditions.RequiredForCondition"
        }
    ]
}